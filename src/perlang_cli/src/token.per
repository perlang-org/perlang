#c++-prototypes
Token* create_string_token(TokenType::TokenType token_type, const char* lexeme, const char* literal, const char* file_name, int line);
Token* create_char_token(TokenType::TokenType token_type, const char* lexeme, char16_t literal, const char* file_name, int line);
Token* create_null_token(TokenType::TokenType token_type, const char* lexeme, const char* file_name, int line);
void delete_token(Token* token);

bool is_string_token(Token* token);
bool is_char_token(Token* token);
bool is_null_token(Token* token);

const char* get_token_lexeme(Token* token);
const char* get_token_string_literal(Token* token);
uint16_t get_token_char_literal(Token* token);
const char* get_token_file_name(Token* token);

#/c++-prototypes

public class Token
{
    private token_type_: TokenType;
    private lexeme_: string;
    private literal_: object;
    private file_name_: string;
    private line_: int;

    public constructor(token_type: TokenType, lexeme: string, literal: object, file_name: string, line: int)
    {
        token_type_ = token_type;
        lexeme_ = lexeme;
        literal_ = literal;
        file_name_ = file_name;
        line_ = line;
    }

    // TODO: Could be called token_type but requires renaming on the C# as well
    public type(): TokenType
    {
        return token_type_;
    }

    public lexeme(): string
    {
        return lexeme_;
    }

    public literal(): object
    {
        return literal_;
    }

    public file_name(): string
    {
        return file_name_;
    }

    public line(): int
    {
        return line_;
    }
}

#c++-methods
Token* create_string_token(TokenType::TokenType token_type, const char* lexeme, const char* literal, const char* file_name, int line)
{
    if (literal == nullptr) {
        throw std::invalid_argument("literal argument cannot be null");
    }

    return new Token(token_type, perlang::UTF8String::from_copied_string(lexeme), perlang::UTF8String::from_copied_string(literal), perlang::UTF8String::from_copied_string(file_name), line);
}

Token* create_char_token(TokenType::TokenType token_type, const char* lexeme, char16_t literal, const char* file_name, int line)
{
    return new Token(token_type, perlang::UTF8String::from_copied_string(lexeme), perlang::Char::from(literal), perlang::UTF8String::from_copied_string(file_name), line);
}

Token* create_null_token(TokenType::TokenType token_type, const char* lexeme, const char* file_name, int line)
{
    return new Token(token_type, perlang::UTF8String::from_copied_string(lexeme), nullptr, perlang::UTF8String::from_copied_string(file_name), line);
}

// Must be called explicitly from the C# side, since CppSharp doesn't give us an easy way to pass ownership over to C#.
void delete_token(Token* token)
{
    delete token;
}

bool is_string_token(Token* token)
{
    auto literal = token->literal().get();

    // This will be the case for null tokens
    if (literal == nullptr) {
        return false;
    }

    // TODO: Replace with proper is_assignable_to() check once we have a more sophisticated perlang::Type
    // implementation, supporting it.
    if (*literal->get_type() == *perlang::ASCIIString::from_static_string("perlang.ASCIIString") ||
        *literal->get_type() == *perlang::ASCIIString::from_static_string("perlang.UTF8String")) {
        return true;
    }
    else {
        return false;
    }
}

bool is_char_token(Token* token)
{
    auto literal = token->literal().get();

    // This will be the case for null tokens
    if (literal == nullptr) {
        return false;
    }

    return (*literal->get_type() == *perlang::ASCIIString::from_static_string("perlang.Char"));
}

bool is_null_token(Token* token)
{
    auto literal = token->literal().get();
    return literal == nullptr;
}

const char* get_token_lexeme(Token* token)
{
    // TODO: This (and the other similar methods) work, under the crude assumption that the underlying string is
    // actually UTF-8 encoded (i.e. no UTF16String). When the 'as_utf8()' method exists in the String class, we should
    // use that to ensure that we don't get any surprises here.
    return token->lexeme()->bytes();
}

const char* get_token_string_literal(Token* token)
{
    auto literal = token->literal().get();

    // TODO: Replace with is_assignable_to() check
    if (*literal->get_type() == *perlang::ASCIIString::from_static_string("perlang.ASCIIString") ||
        *literal->get_type() == *perlang::ASCIIString::from_static_string("perlang.UTF8String")) {
        return ((perlang::String*)literal)->bytes();
    }
    else {
        throw perlang::IllegalStateException(*perlang::ASCIIString::from_static_string("Token expected to be string, not ") + *literal->get_type());
    }
}

uint16_t get_token_char_literal(Token* token)
{
    auto literal = token->literal().get();

    if (*literal->get_type() == *perlang::ASCIIString::from_static_string("perlang.Char")) {
        return ((perlang::Char*)literal)->value();
    }
    else {
        throw perlang::IllegalStateException(*perlang::ASCIIString::from_static_string("Token expected to be string, not ") + *literal->get_type());
    }
}

const char* get_token_file_name(Token* token)
{
    return token->file_name()->bytes();
}

#/c++-methods
